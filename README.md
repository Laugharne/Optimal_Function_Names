# Bien nommer vos fonctions en Solidity : Maximisez l'efficacit√© des EVMs

<!-- TOC -->

- [Bien nommer vos fonctions en Solidity : Maximisez l'efficacit√© des EVMs](#bien-nommer-vos-fonctions-en-solidity--maximisez-lefficacit%C3%A9-des-evms)
	- [TL;DR](#tldr)
	- [Introduction](#introduction)
	- [Pr√©sentation du "function dispatcher"](#pr%C3%A9sentation-du-function-dispatcher)
	- [Fonctionnement](#fonctionnement)
	- [Idnetit√©s et Signatures des fonctions](#idnetit%C3%A9s-et-signatures-des-fonctions)
		- [En Solidity](#en-solidity)
			- [Rappel sur les visibilit√©s des fonctions Solidity](#rappel-sur-les-visibilit%C3%A9s-des-fonctions-solidity)
			- [√Ä la compilation](#%C3%A0-la-compilation)
				- [Code g√©n√©r√©](#code-g%C3%A9n%C3%A9r%C3%A9)
				- [Diagramme](#diagramme)
				- [Ordre d'√©valuation](#ordre-d%C3%A9valuation)
				- [getter automatique](#getter-automatique)
		- [En Yul](#en-yul)
	- [√áa se complique !](#%C3%A7a-se-complique-)
		- [Seuils](#seuils)
		- [fonctions](#fonctions)
		- [Pseudo-code](#pseudo-code)
		- [Calcul des couts en Gas](#calcul-des-couts-en-gas)
		- [Statistiques de consommation](#statistiques-de-consommation)
	- [Algorithmes et ordre de traitement](#algorithmes-et-ordre-de-traitement)
		- [Recherche lin√©aire](#recherche-lin%C3%A9aire)
		- [Recherche "binaire"](#recherche-binaire)
	- [Les optimisations](#les-optimisations)
		- [Optimisation √† l'ex√©cution](#optimisation-%C3%A0-lex%C3%A9cution)
		- [Optimisation √† la transaction](#optimisation-%C3%A0-la-transaction)
	- [Conclusions](#conclusions)
	- [Liens](#liens)

<!-- /TOC -->


## TL;DR

- Le "*function dispatcher*" est une interface d'acc√®s au smart contract, c'est la porte d'entr√©e de l'ext√©rieur vers le contrat.
- Ne concerne que les fonctions ayant un acc√®s vers l'ext√©rieur du contrat.
- Pourrait s'appeler "external access dispatcher", car concerne aussi les donn√©es publiques.
- Coder en Yul, r√©sout la probl√©matique de l'odonnancement.
- Le renommage appropri√© des noms de fonctions est une optimisation de Gas, au d√©ploiement comme √† l'ex√©cution de ces derni√®res.


## Introduction

L'optimisation des co√ªts en Gas est un enjeu cl√© dans le d√©veloppement de contrats intelligents sur la blockchain Ethereum. Chaque op√©ration effectu√©e sur Ethereum a un co√ªt en Gas, qui d√©pend en partie de la complexit√© des fonctions appel√©es.

Dans cet article, nous allons explorer comment le simple fait de nommer vos fonctions peut influencer les co√ªts en Gas associ√©s √† votre contrat.

Nous discuterons de diverses strat√©gies d'optimisation, de l'ordre des hash de signatures aux astuces de renommage des fonctions, afin de r√©duire les co√ªts de d√©ploiement et d'appel de vos contrats.


## Pr√©sentation du "function dispatcher"

Le "*function dispatcher*" (ou gestionnaire de fonctions) dans les contrats intelligents (*smart contracts*) √©crits pour les **EVMs** est un √©l√©ment du contrat qui permet de d√©terminer quelle fonction doit √™tre ex√©cut√©e lorsque quelqu'un interagit avec le contrat au travers d'une API.

Si on imagine un contrat intelligent comme une bo√Æte noire avec des fonctions √† l'int√©rieur.  Ces fonctions peuvent √™tre comme des commandes que vous pouvez donner √† la bo√Æte pour lui faire faire diff√©rentes choses.

Le "*function dispatcher*" √©coute les commandes et dirige chaque commande vers la fonction appropri√©e √† l'int√©rieur de la bo√Æte.  En cela il est le reflet de l'**ABI** cot√© EVM.

Lorsque vous interagissez avec un contrat intelligent en utilisant une application ou une transaction, vous sp√©cifiez quelle fonction vous souhaitez ex√©cuter. Le "*function dispatcher*" fait donc le lien entre la commande et la fonction sp√©cifique qui sera appel√©e et ex√©cut√©e.

En r√©sum√©, le "*function dispatcher*" est comme un chef d'orchestre lors des appels aux fonctions d'un contrat intelligent. Il garantit que les bonnes fonctions sont appel√©es lorsque vous effectuez les bonnes actions sur le contrat.



## Fonctionnement

Lors d'un appel √† une fonction d'un smart contract, le "*function dispatcher*" r√©cup√®re l'identit√© dans le `calldata` produit un `revert` si l'appel ne peut √™tre mis en relation avec une fonction du contrat.

Le m√©canisme de s√©lection est similaire, √† un celui d'une structure `switch/case` ou d'un ensemble de `if/else` tel qu'on le trouve dans de nombreux autres langages de programmation.


## Idnetit√©s et Signatures des fonctions

La **signature** d'une fonction tel que employ√©e avec les **EVMs** (Solidity) consiste en la concat√©nation de son nom et de ses param√®tres (sans noms de param√®tre, sans type de retour et sans espace)

L'**identit√©** (*"selector" dans certaines publications anglo-saxonnes*) est l'identit√© m√™me de la fonction qui la rend "unique" et identifiable, dans le cas de Solidity, il s'agit des 4 octets de poids fort (32 bits) du r√©sultat du hachage de la signature de la fonction avec l'algorithme [**Keccak-256**](https://www.geeksforgeeks.org/difference-between-sha-256-and-keccak-256/)  (üá¨üáß).

Cela selon les [**sp√©cifications de l'ABI en Solidity**](https://docs.soliditylang.org/en/develop/abi-spec.html#function-selector)  (üá¨üáß).

Je pr√©cise bien que je parle de l'identit√© pour le compilateur **Solidity**, ce n'est pas forc√©ment le cas avec d'autres langages comme **Rust** qui fonctionne sur un tout autre paradigme.

Si les types des param√®tres sont pris en compte, c'est pour diff√©rencier les fonctions qui auraient le m√™me nom, mais des param√®tres diff√©rents, comme pour la m√©thode `safeTransferFrom` des tokens  [**ERC721**](https://eips.ethereum.org/EIPS/eip-721)  (üá¨üáß).

Cependant, le fait que l'on ne garde que **quatre octets** pour l'identit√©, implique de potentiels **risques de collisions de hash** entre deux fonctions, risque rare, mais existant malgr√© plus de 4 milliards de possibilit√©s (2^32).

Comme en atteste le site [**Ethereum Signature Database**](https://www.4byte.directory/signatures/?bytes4_signature=0xcae9ca51)  (üá¨üáß) avec l'exemple suivant :

| Identit√©s    | Signatures                                                   |
| ------------ | ------------------------------------------------------------ |
| `0xcae9ca51` | `onHintFinanceFlashloan(address,address,uint256,bool,bytes)` |
| `0xcae9ca51` | `approveAndCall(address,uint256,bytes)`                      |

Un simple contrat Solidity dot√© de ces deux fonctions ne se compile heureusement pas.

```
TypeError: Function signature hash collision for approveAndCall(address,uint256,bytes)
  --> contracts/HashCollision.sol:10:1:
   |
10 | contract HashCollision {
   | ^ (Relevant source part starts here and spans across multiple lines).
```

Mais n'en demeure pas moins probl√©matique : Voir le challenge [**Hint-finance**](https://github.com/paradigmxyz/paradigm-ctf-2022/tree/main/hint-finance), au [**Web3 Hacking: Paradigm CTF 2022**](https://medium.com/amber-group/web3-hacking-paradigm-ctf-2022-writeup-3102944fd6f5) (üá¨üáß)


### En Solidity

En mettant en application ce qui a √©t√© dit plus haut, on obtient, pour la fonction suivante :

```solidity
function square(uint32 num) public pure returns (uint32) {
    return num * num;
}
```

Les signature, hash et identit√© suivantes :

| Fonction  | square(uint32 num) public pure returns (uint32)                    |
| --------- | ------------------------------------------------------------------ |
| Signature | `square(uint32)`                                                   |
| Hash      | `d27b38416d4826614087db58e4ea90ac7199f7f89cb752950d00e21eb615e049` |
| Identit√©  | `d27b3841`                                                         |


En Solidity, le "*function dispatcher*" est g√©n√©r√© par le compilateur, inutile donc de se charger du codage de cette t√¢che complexe. 

Il ne concerne que les fonctions d'un contrat ayant un acc√®s vers l'ext√©rieur de celui-ci, en l'occurrence les fonctions ayant pour attribut d'acc√®s external et public


#### Rappel sur les visibilit√©s des fonctions Solidity

1. **External** : Les fonctions externes sont con√ßues pour √™tre appel√©es depuis l'**ext√©rieur du contrat**, g√©n√©ralement par d'autres contrats ou des comptes externes. C'est le niveau de visibilit√© que vous utilisez lorsque vous souhaitez exposer une interface publique √† votre contrat.

2. **Public** : Les fonctions publiques sont similaires aux fonctions externes, mais elles offrent √©galement une m√©thode de lecture de donn√©es qui ne consomme pas de Gas. Les fonctions publiques sont accessibles depuis l'**ext√©rieur du contrat**.

3. **Internal** : Les fonctions internes peuvent √™tre appel√©es √† l'**int√©rieur du contrat**, ainsi que depuis d'autres **contrats h√©ritant** du contrat actuel. Elles ne sont pas accessibles depuis l'ext√©rieur du contrat via une transaction directe.

**Exemple #1** :

```solidity
pragma solidity 0.8.13;

contract MyContract {
    uint256 public value;
    uint256 internalValue;

    function setValue(uint256 _newValue) external {
        value = _newValue;
    }

    function getValue() public view returns (uint256) {
        return value;
    }

    function setInternalValue(uint256 _newValue) internal {
        internalValue = _newValue;
    }

    function getInternalValue() public view returns (uint256) {
        return internalValue;
    }
}
```

Dans cet exemple, la fonction `setValue` est marqu√©e comme "*external*" car elle modifie l'√©tat du contrat et doit √™tre appel√©e depuis l'ext√©rieur.

La fonction `getValue` est marqu√©e comme √©tant "*public*", elle permet ainsi de lire la valeur sans en modifier l'√©tat.

La fonction `setInternalValue` peut √™tre appel√©e √† partir de l'int√©rieur du contrat lui-m√™me ou par **d'autres contrats** qui h√©ritent de `MyContract`.

La fonction `getInternalValue` est publique et permet de lire la valeur de `internalValue`.


#### √Ä la compilation

Si nous reprenons le pr√©c√©dent code utilis√© en exemple, nous obtenons les signatures et Identit√©s suivantes :

| Fonctions                                              | Signatures                  | Keccak            | Identit√©s      |
| ------------------------------------------------------ | --------------------------- | ----------------- | -------------- |
| **`setValue(uint256 _newValue) external`**             | `setValue(uint256)`         | `55241077...ecbd` | **`55241077`** |
| **`getValue() public view returns (uint256)`**         | `getValue()`                | `20965255...ad96` | **`20965255`** |
| **`setInternalValue(uint256 _newValue) internal`**     | `setInternalValue(uint256)` | `6115694f...7ce1` | **`6115694f`** |
| **`getInternalValue() public view returns (uint256)`** | `getInternalValue()`        | `e778ddc1...c094` | **`e778ddc1`** |

(*Les hashs issus du Keccak ont √©t√© tronqu√©s volontairement*)

Si on examine l'ABI g√©n√©r√© lors de la compilation, la fonction `setInternalValue()` n'apparait pas, ce qui est normal, sa visibilit√© √©tant `internal` (voir plus haut)

On notera dans les donn√©es de l'ABI, la r√©f√©rence √† la donn√©e du storage `value` qui est `public` (on y reviendra plus loin)


##### Code g√©n√©r√©

Voici en extrait le code du "*function dispatcher*" g√©n√©r√© par le compilateur `solc` (version de solidity : 0.8.13)

```yul
tag 1
  JUMPDEST 
  POP 
  PUSH 4
  CALLDATASIZE 
  LT 
  PUSH [tag] 2
  JUMPI 
  PUSH 0
  CALLDATALOAD 
  PUSH E0
  SHR 
  DUP1 
  PUSH 20965255
  EQ 
  PUSH [tag] getValue_0
  JUMPI 
  DUP1 
  PUSH 3FA4F245  
  EQ 
  PUSH [tag] 4
  JUMPI 
  DUP1 
  PUSH 55241077
  EQ 
  PUSH [tag] setValue_uint256_0
  JUMPI 
  DUP1 
  PUSH E778DDC1
  EQ 
  PUSH [tag] getInternalValue_0
  JUMPI 
tag 2
  JUMPDEST 
  PUSH 0
  DUP1 
  REVERT
```

##### Diagramme

Sous forme de diagramme, on comprend mieux la suite de structure de `if/else` en cascade.

![](functions_dispatcher_diagram.png)
<!-- ![](functions_dispatcher_diagram.svg) -->


##### Ordre d'√©valuation

**Important** : L'ordre d'√©valuation des fonctions n'est pas le m√™me que celui de d√©claration dans le code !

| Ordre d'√©valuation | Ordre dans le code | Identit√©s   | Signatures                     |
| ------------------ | ------------------ | ----------- | ------------------------------ |
| 1                  | **3**              | `20965255`  | `getValue()`                   |
| 2                  | **1**              | `3FA4F245`  | `value` (*getter automatique*) |
| 3                  | **2**              | `55241077`  | `setValue(uint256)`            |
| 4                  | **4**              | `E778DDC1`  | `getInternalValue()`           |

En effet, les √©valuations des Identit√©s de fonctions sont ordonn√©es par un tri ascendant sur leurs valeurs.

`20965255` < `3FA4F245` < `55241077` < `E778DDC1`


##### getter() automatique

La fonction d'identit√© `3FA4F245` est en fait un **getter** automatique de la donn√©e publique `value`, elle est g√©n√©r√©e par le compilateur.

```solidity
  uint256 public value;
```

Nous retrouvons d'ailleurs dans les opcodes, l'identit√© de s√©lection (`3FA4F245`) et la fonction (√† l'adresse `tag 4`) du getter automatique pour cette variable.

**S√©lecteur** :
```yul
  DUP1 
  PUSH 3FA4F245  
  EQ 
  PUSH [tag] 4
  JUMPI 
```

**Fonction** :
```yul
tag 4
  JUMPDEST 
  PUSH [tag] 11
  PUSH [tag] 12
  JUMP [in]
tag 11
  JUMPDEST 
  PUSH 40
  MLOAD 
  PUSH [tag] 13
  SWAP2 
  SWAP1 
  PUSH [tag] abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed_0
  JUMP [in]
tag 13
  JUMPDEST 
  PUSH 40
  MLOAD 
  DUP1 
  SWAP2 
  SUB 
  SWAP1 
  RETURN
```

`getter` ayant d'ailleurs un code identique √† celui de la fonction `getValue()`

```yul
tag getValue_0
  JUMPDEST 
  PUSH [tag] getValue_1
  PUSH [tag] getValue_3
  JUMP [in]
tag getValue_1
  JUMPDEST 
  PUSH 40
  MLOAD 
  PUSH [tag] getValue_2
  SWAP2 
  SWAP1 
  PUSH [tag] abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed_0
  JUMP [in]
tag getValue_2
  JUMPDEST 
  PUSH 40
  MLOAD 
  DUP1 
  SWAP2 
  SUB 
  SWAP1 
  RETURN 
```

D√©montrant ainsi l'inutilit√© d'avoir la variable `value` avec l'attribut `public` de concert avec la fonction `getValue()` mais √©galement une faiblesse du compilateur de Solidity `solc` qui ne peut fusionner le code des deux fonctions.

Voici d'ailleurs un lien, pour ceux qui voudraient aller plus loin, [**un article d√©taill√©**](https://medium.com/coinmonks/soliditys-cheap-public-face-b4e972e3924d) (üá¨üáß) sur les `automatic storage getters` en Solidity. Dont on peut r√©sum√© le contenu en quatre points essentiels.

1. Utilisez les getters automatique de Solidity lorsque cela est possible, car ils seront toujours similaires ou moins chers en Gas que les getters explicites. Dans certains cas, par exemple une structure de stockage publique (`public` storage) ils peuvent √™tre le seul moyen de fournir un getter.

2. Bien que le code source du contrat avec les getters automatique soit plus court que celui avec des getters explicites, le co√ªt du Gas est sensiblement le m√™me. Les getters automatiques ne sont pas ¬´ *gratuits* ¬ª.

3. Ne publiez que les variables de stockage qui sont essentiels, en raison du co√ªt du Gas. En particulier, essayez d'√©viter les getters pour les structures de donn√©es dynamiques. Les types de structures complexes, y compris les cha√Ænes, sont assez co√ªteux √† rendre publics.

4. Des getters explicites peuvent √™tre requis pour les types `array` et `mapping`. Ils ne sont pas g√©n√©r√©s automatiquement.


### En Yul

Voici un extrait d'un exemple de [**contrat ERC20**](https://docs.soliditylang.org/en/develop/yul.html#complete-erc20-example) (üá¨üáß) enti√®rement √©crit en **Yul**.

```yul
object "runtime" {
    code {
        // Protection against sending Ether
        require(iszero(callvalue()))

        // Dispatcher
        switch selector()
        case 0x70a08231 /* "balanceOf(address)" */ {
            returnUint(balanceOf(decodeAsAddress(0)))
        }
        case 0x18160ddd /* "totalSupply()" */ {
            returnUint(totalSupply())
        }
        case 0xa9059cbb /* "transfer(address,uint256)" */ {
            transfer(decodeAsAddress(0), decodeAsUint(1))
            returnTrue()
        }
        case 0x23b872dd /* "transferFrom(address,address,uint256)" */ {
            transferFrom(decodeAsAddress(0), decodeAsAddress(1), decodeAsUint(2))
            returnTrue()
        }
        case 0x095ea7b3 /* "approve(address,uint256)" */ {
            approve(decodeAsAddress(0), decodeAsUint(1))
            returnTrue()
        }
        case 0xdd62ed3e /* "allowance(address,address)" */ {
            returnUint(allowance(decodeAsAddress(0), decodeAsAddress(1)))
        }
        case 0x40c10f19 /* "mint(address,uint256)" */ {
            mint(decodeAsAddress(0), decodeAsUint(1))
            returnTrue()
        }
        default {
            revert(0, 0)
        }

        /* ---------- calldata decoding functions ----------- */
        function selector() -> s {
            s := div(calldataload(0), 0x100000000000000000000000000000000000000000000000000000000)
        }

  ...

```

On y retrouve la suite de structure de `if/else` en cascade, identique au diagramme pr√©c√©dent.

R√©aliser un contrat **100% en Yul**, oblige √† coder soi-m√™me le "*function dispatcher*", ce qui implique que l'on peut choisir l'ordre de traitement des identit√©s, ainsi qu'utiliser d'autres algorithmes qu'une simple suite de tests en cascade.


## √áa se complique !

Maintenant, voici un tout autre exemple pour illustrer le fait que les choses sont plus complexes que cela en fonction du **nombre de fonctions** et du **niveau d'optimisation** du compilateur Solidity (voir : `--optimize-runs`) !

**Exemple #2** :

```solidity
// SPDX-License-Identifier: GPL-3.0

pragma solidity 0.8.17;

contract Storage {

    uint256 numberA;
    uint256 numberB;
    uint256 numberC;
    uint256 numberD;
    uint256 numberE;


    // identity : C534BE7A
    function storeA(uint256 num) public {
        numberA = num;
    }

    // identity : 9AE4B7D0
    function storeB(uint256 num) public {
        numberB = num;
    }

    // identity : 4CF56E0C
    function storeC(uint256 num) public {
        numberC = num;
    }

    // identity : B87C712B
    function storeD(uint256 num) public {
        numberD = num;
    }

    // identity : E45F4CF5
    function storeE(uint256 num) public {
        numberE = num;
    }

    // identity : 2E64CEC1
    function retrieve() public view returns (uint256) {
        return Multiply( numberA, numberB, numberC, numberD);
    }


    function Multiply(uint a, uint b, uint c, uint d) pure private returns(uint256) {
        return a * b * c * d;
    }

    function MultiplyBis(uint a, uint b, uint c, uint d) pure private returns(uint256) {
        return a * b * c * d;
    }

}
```
Nous avons bien 6 fonctions pr√©sentes dans le JSON de l'ABI. Les **6 fonctions `public`** suivantes avec leur identit√©s d√©di√©es :

| Fonctions                                      | Signatures        | Identit√©s      |
| ---------------------------------------------- | ----------------- | -------------- |
| **`storeA(uint256 num) public`**               | `storeA(uint256)` | **`C534BE7A`** |
| **`storeB(uint256 num) public`**               | `storeB(uint256)` | **`9AE4B7D0`** |
| **`storeC(uint256 num) public`**               | `storeC(uint256)` | **`4CF56E0C`** |
| **`storeD(uint256 num) public`**               | `storeD(uint256)` | **`B87C712B`** |
| **`storeE(uint256 num) public`**               | `storeE(uint256)` | **`E45F4CF5`** |
| **`retrieve() public view returns (uint256)`** | `retrieve()`      | **`2E64CEC1`** |

Suivant le [**niveau d'optimisation**](https://docs.soliditylang.org/en/develop/internals/optimizer.html) (üá¨üáß) du compilateur, nous obtenons un code diff√©rent pour le "*function dispatcher*".

Avec un niveau √† **200** (*`--optimize-runs 200`*) nous obtenons le type de code pr√©c√©demment g√©n√©r√©, avec ses `if/else` en cascade.

```yul
tag 1
  JUMPDEST 
  POP 
  PUSH 4
  CALLDATASIZE 
  LT 
  PUSH [tag] 2
  JUMPI 
  PUSH 0
  CALLDATALOAD 
  PUSH E0
  SHR 
  DUP1 
  PUSH 2E64CEC1
  EQ 
  PUSH [tag] retrieve_0
  JUMPI 
  DUP1 
  PUSH 4CF56E0C
  EQ 
  PUSH [tag] storeC_uint256_0
  JUMPI 
  DUP1 
  PUSH 9AE4B7D0
  EQ 
  PUSH [tag] storeB_uint256_0
  JUMPI 
  DUP1 
  PUSH B87C712B
  EQ 
  PUSH [tag] storeD_uint256_0
  JUMPI 
  DUP1 
  PUSH C534BE7A
  EQ 
  PUSH [tag] storeA_uint256_0
  JUMPI 
  DUP1 
  PUSH E45F4CF5
  EQ 
  PUSH [tag] storeE_uint256_0
  JUMPI 
  PUSH 0
  DUP1
  REVERT
```

Par contre, avec un niveau de `runs` plus √©lev√© (*`--optimize-runs 300`*)

```yul
tag 1
  JUMPDEST
  POP
  PUSH 4
  CALLDATASIZE
  LT
  PUSH [tag] 2
  JUMPI
  PUSH 0
  CALLDATALOAD
  PUSH E0
  SHR
  DUP1
  PUSH B87C712B
  GT
  PUSH [tag] 9
  JUMPI
  DUP1
  PUSH B87C712B
  EQ
  PUSH [tag] storeD_uint256_0
  JUMPI
  DUP1
  PUSH C534BE7A
  EQ
  PUSH [tag] storeA_uint256_0
  JUMPI
  DUP1
  PUSH E45F4CF5
  EQ
  PUSH [tag] storeE_uint256_0
  JUMPI
  PUSH 0
  DUP1
  REVERT
tag 9
  JUMPDEST
  DUP1
  PUSH 2E64CEC1
  EQ
  PUSH [tag] retrieve_0
  JUMPI
  DUP1
  PUSH 4CF56E0C
  EQ
  PUSH [tag] storeC_uint256_0
  JUMPI
  DUP1
  PUSH 9AE4B7D0
  EQ
  PUSH [tag] storeB_uint256_0
  JUMPI
tag 2
  JUMPDEST
  PUSH 0
  DUP1
  REVERT
```

Les opcodes et le flux d'ex√©cution, ne sont plus les m√™mes.

![](functions_split_dispatcher_diagram.png)

On voit que les tests sont "d√©coup√©s" en deux recherches lin√©aires autour d'une valeur pivot `B87C712B`. Diminuant ainsi la consommation pour les cas les moins favorables `storeB(uint256)` et `storeE(uint256)`.


### Seuils

Seulement **4 tests** pour les fonctions `storeB(uint256)` et `storeE(uint256)`, au lieu de respectivement **3 tests** et **6 tests** avec le pr√©c√©dent algorithme.

La d√©termination du d√©clenchement de ce type d'optimisation est un peu d√©licat, le seuil du nombre de fonctions se trouve √™tre 6 pour le d√©clencher avec `--optimize-runs 284`, donnant **deux tranches** de 3 s√©ries de tests lin√©aires.


### 11 fonctions

Avec **11 fonctions** √©ligibles, et un niveau de `runs` sup√©rieur `--optimize-runs 1000`  on passe de **deux tranches** (une de 6 + une de 5) √† **4 tranches** (trois tranches de 3 + une de 2)

Ces seuils (valeur de `runs`) sont-t-il susceptibles d'√©voluer au fil des versions du compilateur `solc` ?


### Pseudo-code

Cette fois-ci, je ne reproduit pas les opcodes et le diagramme associ√©, afin de clarifier l'explication, voici le flux d'ex√©cution sous forme de *pseudo-code*, semblable √† du code **C**.

```c
// [tag 1]
// 1 Gas (JUMPDEST)
if( selector >= 0x799EBD70) {  // 22 = (3+3+3+3+10) Gas
  if( selector >= 0xB9E9C35C) {  // 22 = (3+3+3+3+10) Gas
    if( selector == 0xB9E9C35C) { goto storeF }  // 22 = (3+3+3+3+10) Gas
    if( selector == 0xC534BE7A) { goto storeA }  // 22 = (3+3+3+3+10) Gas
    if( selector == 0xE45F4CF5) { goto storeE }  // 22 = (3+3+3+3+10) Gas
    revert()
  }
  // [tag 15]
  // 1 Gas (JUMPDEST)
  if( selector == 0x799EBD70) { goto storeG }  // 22 = (3+3+3+3+10) Gas
  if( selector == 0x9AE4B7D0) { goto storeB }  // 22 = (3+3+3+3+10) Gas
  if( selector == 0xB87C712B) { goto storeD }  // 22 = (3+3+3+3+10) Gas
  revert()
} else {
  // [tag 14]
  // 1 Gas (JUMPDEST)
  if( selector >= 0x4CF56E0C) { // 22 = (3+3+3+3+10) Gas
    if( selector == 0x4CF56E0C) { goto storeC }  // 22 = (3+3+3+3+10) Gas
    if( selector == 0x6EC51CF6) { goto storeJ }  // 22 = (3+3+3+3+10) Gas
    if( selector == 0x75A64B6D) { goto storeH }  // 22 = (3+3+3+3+10) Gas
    revert()
  }
  // [tag 16]
  // 1 Gas (JUMPDEST)
  if( selector == 0x183301E7) { goto storeI }    // 22 = (3+3+3+3+10) Gas
  if( selector == 0x2E64CEC1) { goto retrieve }  // 22 = (3+3+3+3+10) Gas
  revert()
}
```

On distingue mieux les articulations autour des diff√©rentes valeurs "pivots" `799EBD70`, `0x4CF56E0C` et `0xB9E9C35C`.


### Calcul des couts en Gas

J'ai pris pour r√©f√©rence toujours le m√™me code d'un contrat Solidity avec **11 fonctions √©ligibles** au "*function dispatcher*", afin d'estimer le cout en Gas, selon que l'on ait une recherche lin√©aire ou "binaire".

- On ne prendra pas en compte dans les couts en Gas la portion de code qui va extraire l'identit√© de la fonction, en allant chercher la donn√©e dans la zone `calldata`.

- Ni les couts de Gas n√©cessaire au stockage de donn√©es dans l'EVM

- De m√™me ne sera pas pris en compte les cas ou la recherche √©chouera et aboutira donc √† un `revert`.

- C'est uniquement le **cout de la s√©lection** dans le "*function dispatcher*" et non l'ex√©cution des fonctions qui est estim√©. Nous ne nous pr√©occupons pas de ce que fait la fonction elle-m√™me ni de ce qu'elle consomme comme Gas.

L'estimation des couts en Gas des opcodes utilis√©s ont √©t√© r√©alis√©s en m'aidant des sites suivants :
- [**Ethereum Yellow Paper**](https://ethereum.github.io/yellowpaper/paper.pdf) (üá¨üáß)
- [**EVM Codes - An Ethereum Virtual Machine Opcodes Interactive Reference**](https://www.evm.codes/?fork=shanghai) (üá¨üáß)


Les **opcodes** en jeu sont ainsi les suivants :

| Mnemonic           | Gas | Description                             |
| ------------------ | --- | --------------------------------------- |
| `JUMPDEST`         | 1   | Mark valid jump destination.            |
| `DUP1`             | 3   | Clone 1st value on stack                |
| `PUSH4 0xXXXXXXXX` | 3   | Push 4-byte value onto stack.           |
| `GT`               | 3   | Greater-than comparison.                |
| `EQ`               | 3   | Equality comparison.                    |
| `PUSH [tag]`       | 3   | Push 2-byte value onto stack.           |
| `JUMPI`            | 10  | Conditionally alter the program counter |


Ce qui m'a permit d'estimer les couts en Gas de recherche de chaque fonction, selon l'algorithme.

| Signatures        | Identit√©s        | Gas (linear)    | Gas (binary)    |
| ----------------- | ---------------- | --------------- | --------------- |
| `storeI(uint256)` | `183301E7`       | **22 (*min*)**  | 69              |
| `retrieve()`      | `2E64CEC1`       | 44              | 91              |
| `storeC(uint256)` | `4CF56E0C` (*2*) | 66              | 69              |
| `storeJ(uint256)` | `6EC51CF6`       | 88              | 90              |
| `storeH(uint256)` | `75A64B6D`       | 110             | **112 (*max*)** |
| `storeG(uint256)` | `799EBD70` (*1*) | 132             | 68              |
| `storeB(uint256)` | `9AE4B7D0`       | 154             | 90              |
| `storeD(uint256)` | `B87C712B`       | 176             | **112 (*max*)** |
| `storeF(uint256)` | `B9E9C35C` (*2*) | 198             | **67 (*min*)**  |
| `storeA(uint256)` | `C534BE7A`       | 220             | 89              |
| `storeE(uint256)` | `E45F4CF5`       | **242 (*max*)** | 111             |

- (*1*) : *premier seuil*
- (*2*) : *seuils secondaires*


### Statistiques de consommation

Si on regarde d'un peu plus pr√®s le r√©sultat de certaines **statistiques** sur les deux types de recherche.

| \          | Linear | Binary    |
| ---------- | ------ | --------- |
| Min        | **22** | 67        |
| Max        | 242    | **112**   |
| Moyenne    | 132    | **88**    |
| Ecart-type | 72,97  | **18,06** |

On constate des diff√©rences notables. En l'occurrence, une **moyenne** plus basse (*-33%*) avec une [**dispersion**](https://fr.wikipedia.org/wiki/%C3%89cart_type) des consommations consid√©rablement plus faible (*4 fois moins*) en faveur de la recherche "binaire".


## Algorithmes et ordre de traitement

Suivant l'algorithme utilis√© par le compilateur Solidity pour g√©n√©rer le "*function dispatcher*", l'ordre de traitement des fonctions sera diff√©rent, aussi bien de l'ordre de d√©claration dans le code source que de l'ordre alphab√©tique.


### Recherche lin√©aire

| #      | Signatures        |
| ------ | ----------------- |
| **1**  | `storeI(uint256)` |
| **2**  | `retrieve()`      |
| **3**  | `storeC(uint256)` |
| **4**  | `storeJ(uint256)` |
| **5**  | `storeH(uint256)` |
| **6**  | `storeG(uint256)` |
| **7**  | `storeB(uint256)` |
| **8**  | `storeD(uint256)` |
| **9**  | `storeF(uint256)` |
| **10** | `storeA(uint256)` |
| **11** | `storeE(uint256)` |

Le nombre de tests et la complexit√© du processus est proportionnelle au nombre de fonctions, en [**O(n)**](https://fr.wikipedia.org/wiki/Complexit%C3%A9_en_temps#Liste_de_complexit%C3%A9s_en_temps_classiques).


### Recherche "binaire"

| #      | Signatures        |
| ------ | ----------------- |
| **1**  | `storeF(uint256)` |
| **2**  | `storeG(uint256)` |
| **3**  | `storeI(uint256)` |
| **4**  | `storeC(uint256)` |
| **5**  | `storeA(uint256)` |
| **6**  | `storeJ(uint256)` |
| **7**  | `storeB(uint256)` |
| **8**  | `retrieve()`      |
| **9**  | `storeE(uint256)` |
| **10** | `storeH(uint256)` |
| **11** | `storeD(uint256)` |

Il ne s'agit pas d'une [**recherche dichotomique**](https://fr.wikipedia.org/wiki/Recherche_dichotomique) au sens strict du terme, mais plut√¥t d'un d√©coupage en groupes de tests s√©quentiels autour de valeurs pivots. Mais au final, la complexit√© est identique, en [**O(log n)**](https://fr.wikipedia.org/wiki/Complexit%C3%A9_en_temps#Liste_de_complexit%C3%A9s_en_temps_classiques).


## Les optimisations

Si on part sur le principe que les fonctions sont appel√©es de mani√®re √©quitable (√† la m√™me fr√©quance d'utilisation) celles-ci lors de leurs appels ne couteront pas la m√™me chose en fonction de leurs signatures (*et par l√† m√™me de leurs noms*). On voit clairement que tel quel le cout de la s√©lection d'un appel vers ces fonctions, quel que soit l'algorithme, est tr√®s h√©t√©rog√®ne et s'il peut √™tre estim√©, il ne peut √™tre impos√©.

Cependant, en renommant strat√©giquement les fonctions, en ajoutant des suffixes, vous pouvez influencer le r√©sultat des signatures de fonctions et, par cons√©quent, les co√ªts de gaz associ√©s √† ces fonctions. Cette pratique peut permettre d'optimiser la consommation de gaz dans votre contrat intelligent, lors de l'appel de la fonction dans l'EVM, mais aussi, comme nous le verrons plus loin, lors des transactions.


### Optimisation √† l'ex√©cution

Pour illustrer la chose, la signature de la fonction `square(uint32)` modifi√©e ainsi `square_low(uint32)` aura pour identit√© `bde6cad1` au lieu de `d27b3841`.

La valeur inf√©rieure de la nouvelle identit√© obtenue fera ainsi remonter en priorit√© le traitement de l'appel de cette fonction.

Cette optimisation peut √™tre importante pour les contrats intelligents tr√®s complexes, car elle permet de r√©duire le temps n√©cessaire pour rechercher et s√©lectionner la bonne fonction √† appeler, ce qui se traduit par des √©conomies de gaz et des performances am√©lior√©es sur la blockchain Ethereum.

Le fait que la recherche soit "binaire" au lieu de lin√©aire, complique un peu les choses, dans le sens ou en fonction du nombre de fonctions et du niveau d'optimisation du compilateur, les valeurs seuils sont plus d√©licates √† d√©terminer


### Optimisation √† la transaction

Lorsque vous envoyez une transaction sur la blockchain Ethereum, vous incluez g√©n√©ralement des donn√©es qui sp√©cifient quelle fonction du contrat intelligent vous souhaitez appeler et quels sont les arguments de cette fonction. Or le co√ªt en gaz d'une transaction d√©pend en partie du nombre d'octets √† z√©ro dans les donn√©es de cette transaction. 

Comme pr√©cis√© dans l'[**Ethereum Yellow Paper**](https://ethereum.github.io/yellowpaper/paper.pdf) (üá¨üáß)

![](2023-10-10-15-50-45.png)

Pour illustrer la chose, la signature de la fonction `square(uint32)` modifi√©e ainsi `square_Y7i(uint32)` aura pour identit√© `00001878` au lieu de `d27b3841`.

Les deux octets de poids forts de l'identit√©, feront non seulement remonter en priorit√© le **traitement de l'appel** de cette fonction, mais permettra √©galement de consommer **moins de Gas** lors de la transaction (**40** au lieu de **64**).

En voici d'autres exemples :

- `deposit_ps2(uint256)` au lieu de `deposit_ps2(uint256)`
- `mint_540(uint256)` au lieu de `mint(uint256)`
- `b_A6Q()` au lieu de `b()`

Id√©alement, il faudrait trouver des identit√©s avec **trois octets** de poids forts √† z√©ro, permettant ainsi de ne consommer que **28 Gas**.


## Conclusions

- L'optimisation des co√ªts en Gas est un aspect essentiel de la conception de contrats intelligents efficaces sur Ethereum.

- En faisant attention aux d√©tails tels que l'ordre des signatures de fonction, le nombre de z√©ros en d√©but de hash, l'ordre de traitement des fonctions, et le renommage des fonctions, vous pouvez r√©duire de mani√®re significative les co√ªts associ√©s √† votre contrat.

- **Attention** toutefois la convivialit√© et la lisibilit√© de votre code, peut en √™tre l√©gerement r√©duite.

- L'optimisation pour l'ex√©cution n'est pas n√©cessaire pour les fonctions dites d'administration, ou celle trop peu fr√©quement appel√©es.

- Par contre, c'est √† prioriser pour les fonctions suppos√©ment les plus fr√©quemment appel√©es (√† d√©terminer manuellement ou statistiquement lors de tests pratiques).

En fin de compte, ces optimisations peuvent faire la diff√©rence entre un contrat √©conomique et un contrat co√ªteux en Gas.

--------

Cr√©dits : **Franck Maussand franck@maussand.net**

*Merci √† [**Igor Bournazel**](https://github.com/ibourn) pour la relecture de cet article.*

--------

<!-- *Merci √† [**Igor Bournazel**](https://github.com/ibourn) pour la relecture de cet article.* -->


## Liens

- Fonction de hachage
  - üá´üá∑ [Fonction de hachage ‚Äî Wikip√©dia](https://fr.wikipedia.org/wiki/Fonction_de_hachage)
  - üá¨üáß [Hash function - Wikipedia](https://en.wikipedia.org/wiki/Hash_function)

- Keccak
  - üá´üá∑ [SHA-3 ‚Äî Wikip√©dia](https://fr.wikipedia.org/wiki/SHA-3)
  - üá¨üáß [SHA-3 - Wikipedia](https://en.wikipedia.org/wiki/SHA-3)
  - üá¨üáß [Difference Between SHA-256 and Keccak-256 - GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-sha-256-and-keccak-256/)

- Recherche dichotomique
  - üá´üá∑ [Recherche dichotomique ‚Äî Wikip√©dia](https://fr.wikipedia.org/wiki/Recherche_dichotomique)
  - üá¨üáß [Binary search algorithm - Wikipedia](https://en.wikipedia.org/wiki/Binary_search_algorithm)
  - üá´üá∑ [Calculer la performance d'un algorithme avec la notation Big-O](https://buzut.net/cours/computer-science/time-complexity)
  - üá¨üáß [Big O notation - Wikipedia](https://en.wikipedia.org/wiki/Big_O_notation)

- Ref√©rences
  - üá¨üáß [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)
  - üá¨üáß [Opcodes for the EVM](https://ethereum.org/en/developers/docs/evm/opcodes/)
  - üá¨üáß [EVM Codes - An Ethereum Virtual Machine Opcodes Interactive Reference](https://www.evm.codes/?fork=shanghai)
  - üá¨üáß [Operations with dynamic Gas costs](https://github.com/wolflo/evm-opcodes/blob/main/gas.md)
  - üá¨üáß [Contract ABI Specification ‚Äî Solidity 0.8.22 documentation](https://docs.soliditylang.org/en/develop/abi-spec.html#function-selector)
  - üá¨üáß [Yul ‚Äî Solidity 0.8.22 documentation](https://docs.soliditylang.org/en/latest/yul.html)
  - üá¨üáß [Yul ‚Äî Complete ERC20 Example](https://docs.soliditylang.org/en/develop/yul.html#complete-erc20-example)
  - üá¨üáß [Using the Compiler ‚Äî Solidity 0.8.22 documentation](https://docs.soliditylang.org/en/latest/using-the-compiler.html)
  - üá¨üáß [The Optimizer ‚Äî Solidity 0.8.22 documentation](https://docs.soliditylang.org/en/develop/internals/optimizer.html)

- Outils
  - üá¨üáß [Keccak-256 Online](http://emn178.github.io/online-tools/keccak_256.html)
  - üá¨üáß [Compiler Explorer](https://godbolt.org/)
  - üá¨üáß [Solidity Optimize Name](https://emn178.github.io/solidity-optimize-name/)
  - üá¨üáß [Ethereum Signature Database](https://www.4byte.directory/)

- Divers
  - üá¨üáß [Function Dispatching | Huff Language](https://docs.huff.sh/tutorial/function-dispatching/#linear-dispatching)
  - üá¨üáß [Solidity‚Äôs Cheap Public Face](https://medium.com/coinmonks/soliditys-cheap-public-face-b4e972e3924d)
  - üá¨üáß [Web3 Hacking: Paradigm CTF 2022 Writeup](https://medium.com/amber-group/web3-hacking-paradigm-ctf-2022-writeup-3102944fd6f5)
  - üá¨üáß [paradigm-ctf-2022/hint-finance at main ¬∑ paradigmxyz/paradigm-ctf-2022 ¬∑ GitHub](https://github.com/paradigmxyz/paradigm-ctf-2022/tree/main/hint-finance)

