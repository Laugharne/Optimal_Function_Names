# Optimisation des noms de fonctions avec les EVMs

<!-- TOC -->

- [Optimisation des noms de fonctions avec les EVMs](#optimisation-des-noms-de-fonctions-avec-les-evms)
	- [TL;DR](#tldr)
	- [Pr√©sentation du "*function dispatcher*"](#pr%C3%A9sentation-du-function-dispatcher)
	- [Fonctionnement](#fonctionnement)
	- [Idnetit√©s et Signatures des fonctions](#idnetit%C3%A9s-et-signatures-des-fonctions)
		- [En **Solidity**](#en-solidity)
			- [Pour rappel](#pour-rappel)
			- [√Ä la compilation](#%C3%A0-la-compilation)
				- [Code g√©n√©r√©](#code-g%C3%A9n%C3%A9r%C3%A9)
				- [Diagramme](#diagramme)
				- [Ordre d'√©valuation](#ordre-d%C3%A9valuation)
				- [getter automatique](#getter-automatique)
		- [En **Yul**](#en-yul)
	- [Un exemple simple](#un-exemple-simple)
	- [L'ordre de traitement](#lordre-de-traitement)
		- [Recherche lin√©aire](#recherche-lin%C3%A9aire)
		- [Recherche par dichotomie](#recherche-par-dichotomie)
	- [Optimisations](#optimisations)
		- [Optimisation au d√©ploiement](#optimisation-au-d%C3%A9ploiement)
		- [optimisation √† l'ex√©cution](#optimisation-%C3%A0-lex%C3%A9cution)
	- [Conclusions](#conclusions)
	- [Liens](#liens)

<!-- /TOC -->


## TL;DR

- Le "*function dispatcher*" est une interface d'acc√®s au smart contract, c'est la porte d'entr√©e de l'ext√©rieur vers le contrat.
- Ne concerne que les fonctions ayant un acc√®s vers l'ext√©rieur du contrat.
- Pourrait s'appeler "external access dispatcher", car concerne aussi les donn√©es publiques.
- Coder en Yul, r√©sout la probl√©matique de l'odonnancement.
- Le renommage appropri√© des noms de fonctions est une optimisation de Gas, au d√©ploiement et √† l'appel de ces derni√®res.


## Pr√©sentation du "*function dispatcher*"

Le "*function dispatcher*" (ou gestionnaire de fonctions) dans les contrats intelligents (*smart contracts*) √©crits pour les **EVMs** est un √©l√©ment du contrat qui permet de d√©terminer quelle fonction doit √™tre ex√©cut√©e lorsque quelqu'un interagit avec le contrat au travers d'une API.

Si on imagine un contrat intelligent comme une bo√Æte noire avec des fonctions √† l'int√©rieur.  Ces fonctions peuvent √™tre comme des commandes que vous pouvez donner √† la bo√Æte pour lui faire faire diff√©rentes choses.

Le "*function dispatcher*" √©coute les commandes et dirige chaque commande vers la fonction appropri√©e √† l'int√©rieur de la bo√Æte.

Lorsque vous interagissez avec un contrat intelligent en utilisant une application ou une transaction, vous sp√©cifiez quelle fonction vous souhaitez ex√©cuter. Le "*function dispatcher*" fait donc le lien entre la commande et la fonction sp√©cifique qui sera appel√©e et ex√©cut√©e.

En r√©sum√©, le "*function dispatcher*" est comme un chef d'orchestre lors des appels aux fonctions d'un contrat intelligent. Il garantit que les bonnes fonctions sont appel√©es lorsque vous effectuez les bonnes actions sur le contrat.


## Fonctionnement

Lors d'un appel √† une fonction d'un smart contract, le "*function dispatcher*" r√©cup√®re l'identit√© dans le `calldata` produit un `revert` si l'appel ne peut √™tre mis en relation avec une fonction du contrat.

Le m√©canisme de s√©lection est similaire, √† un celui d'une structure `switch/case` ou d'un ensemble de `if/else` tel qu'on le trouve dans de nombreux autres langages de programmation.


## Idnetit√©s et Signatures des fonctions

La **signature** d'une fonction tel que employ√©e avec les **EVMs** (Solidity) consiste en la concat√©nation de son nom et de ses param√®tres (sans noms de param√®tre, sans type de retour et sans espace)

L'**identit√©** (*"selector" dans certaines publications anglo-saxonnes*) est l'identit√© m√™me de la fonction qui la rend "unique" et identifiable, dans le cas de Solidity, il s'agit des 4 octets de poids fort (32 bits) du r√©sultat du hachage de la signature de la fonction avec l'algorithme [**Keccak-256**](https://www.geeksforgeeks.org/difference-between-sha-256-and-keccak-256/)  (üá¨üáß).

Cela selon les [**sp√©cifications de l'ABI en Solidity**](https://docs.soliditylang.org/en/develop/abi-spec.html#function-selector)  (üá¨üáß).

Je pr√©cise bien que je parle de l'identit√© pour le compilateur **Solidity**, ce n'est pas forc√©ment le cas avec d'autres langages comme **Rust** qui fonctionne sur un tout autre paradigme.

Si les types des param√®tres sont pris en compte, c'est pour diff√©rencier les fonctions qui auraient le m√™me nom, mais des param√®tres diff√©rents, comme par exemple la m√©thode `safeTransferFrom` des tokens  [**ERC721**](https://eips.ethereum.org/EIPS/eip-721)  (üá¨üáß).

Cependant, le fait que l'on ne garde que **quatre octets** pour l'identit√©, implique de potentiels **risques de collisions de hash** entre deux fonctions, risque rare, mais existant malgr√© plus de 4 milliards de possibilit√©s (2^32).

Comme en atteste le site [**Ethereum Signature Database**](https://www.4byte.directory/signatures/?bytes4_signature=0xcae9ca51)  (üá¨üáß) avec l'exemple suivant :

| Identit√©s    | Signatures    |
| --- | --- |
| `0xcae9ca51`    | `onHintFinanceFlashloan(address,address,uint256,bool,bytes)`    |
| `0xcae9ca51`    | `approveAndCall(address,uint256,bytes)`    |


### En **Solidity**

En mettant en application ce qui a √©t√© dit plus haut, on obtient, pour la fonction suivante :

```solidity
function square(uint32 num) public pure returns (uint32) {
    return num * num;
}
```

Les signature, hash et identit√© suivantes :

| Fonction  | square(uint32 num) public pure returns (uint32)                    |
| --------- | ------------------------------------------------------------------ |
| Signature | `square(uint32)`                                                   |
| Hash      | `d27b38416d4826614087db58e4ea90ac7199f7f89cb752950d00e21eb615e049` |
| Identit√© | `d27b3841`                                                         |


En Solidity, le "*function dispatcher*" est g√©n√©r√© par le compilateur, inutile donc de se charger du codage de cette t√¢che complexe. 

Il ne concerne que les fonctions d'un contrat ayant un acc√®s vers l'ext√©rieur de celui-ci, en l'occurrence les fonctions ayant pour attribut d'acc√®s external et public


#### Pour rappel

1. **External** : Les fonctions externes sont con√ßues pour √™tre appel√©es depuis l'**ext√©rieur du contrat**, g√©n√©ralement par d'autres contrats ou des comptes externes. C'est le niveau de visibilit√© que vous utilisez lorsque vous souhaitez exposer une interface publique √† votre contrat.

2. **Public** : Les fonctions publiques sont similaires aux fonctions externes, mais elles offrent √©galement une m√©thode de lecture de donn√©es qui ne consomme pas de gaz. Les fonctions publiques sont accessibles depuis l'**ext√©rieur du contrat**.

3. **Internal** : Les fonctions internes peuvent √™tre appel√©es √† l'**int√©rieur du contrat**, ainsi que depuis d'autres **contrats h√©ritant** du contrat actuel. Elles ne sont pas accessibles depuis l'ext√©rieur du contrat via une transaction directe.

**Exemple #1** :

```solidity
pragma solidity 0.8.20;

contract MyContract {
    uint256 public value;
    uint256 internalValue;

    function setValue(uint256 _newValue) external {
        value = _newValue;
    }

    function getValue() public view returns (uint256) {
        return value;
    }

    function setInternalValue(uint256 _newValue) internal {
        internalValue = _newValue;
    }

    function getInternalValue() public view returns (uint256) {
        return internalValue;
    }
}
```

Dans cet exemple, la fonction `setValue` est marqu√©e comme "*external*" car elle modifie l'√©tat du contrat et doit √™tre appel√©e depuis l'ext√©rieur.

La fonction `getValue` est marqu√©e comme √©tant "*public*", elle permet ainsi de lire la valeur sans en modifier l'√©tat.

La fonction `setInternalValue` peut √™tre appel√©e √† partir de l'int√©rieur du contrat lui-m√™me ou par **d'autres contrats** qui h√©ritent de `MyContract`.

La fonction `getInternalValue` est publique et permet de lire la valeur de `internalValue`.


#### √Ä la compilation

Si nous reprenons le pr√©c√©dent code utilis√© en exemple, nous obtenons les signatures et Identit√©s suivantes :

| Fonctions                                              | Signatures                  | Keccak            | Identit√©s     |
| ------------------------------------------------------ | --------------------------- | ----------------- | -------------- |
| **`setValue(uint256 _newValue) external`**             | `setValue(uint256)`         | `55241077...ecbd` | **`55241077`** |
| **`getValue() public view returns (uint256)`**         | `getValue()`                | `20965255...ad96` | **`20965255`** |
| **`setInternalValue(uint256 _newValue) internal`**     | `setInternalValue(uint256)` | `6115694f...7ce1` | **`6115694f`** |
| **`getInternalValue() public view returns (uint256)`** | `getInternalValue()`        | `e778ddc1...c094` | **`e778ddc1`** |

(*Les hashs issus du Keccak ont √©t√© tronqu√©s volontairement*)

Si on examine l'ABI g√©n√©r√© lors de la compilation, la fonction `setInternalValue()` n'apparait pas, ce qui est normal, sa visibilit√© √©tant `internal` (voir plus haut)

On notera dans les donn√©es de l'ABI, la r√©f√©rence √† la donn√©e du storage `value` qui est `public` (on y reviendra plus loin)


##### Code g√©n√©r√©

Voici en extrait le code du "*function dispatcher*" g√©n√©r√© par le compilateur `solc` (version de solidity : 0.8.13)

```yul
tag 1
  JUMPDEST 
  POP 
  PUSH 4
  CALLDATASIZE 
  LT 
  PUSH [tag] 2
  JUMPI 
  PUSH 0
  CALLDATALOAD 
  PUSH E0
  SHR 
  DUP1 
  PUSH 20965255
  EQ 
  PUSH [tag] getValue_0
  JUMPI 
  DUP1 
  PUSH 3FA4F245  
  EQ 
  PUSH [tag] 4
  JUMPI 
  DUP1 
  PUSH 55241077
  EQ 
  PUSH [tag] setValue_uint256_0
  JUMPI 
  DUP1 
  PUSH E778DDC1
  EQ 
  PUSH [tag] getInternalValue_0
  JUMPI 
tag 2
  JUMPDEST 
  PUSH 0
  DUP1 
  REVERT
```

##### Diagramme

Sous forme de diagramme, on comprend mieux la suite de structure de `if/else` en cascade.

![](functions_dispatcher_diagram.png)


##### Ordre d'√©valuation

**Important** : L'ordre d'√©valuation des fonctions n'est pas le m√™me que celui de d√©claration dans le code !

| Ordre d'√©valuation | Ordre dans le code | Identit√©s | Signatures                   |
| ------------------ | ------------------ | ---------- | ---------------------------- |
| 1                  | **3**              | 20965255   | getValue()                   |
| 2                  | **1**              | 3FA4F245   | value (*getter automatique*) |
| 3                  | **2**              | 55241077   | setValue(uint256)            |
| 4                  | **4**              | E778DDC1   | getInternalValue()           |

En effet, les √©valuations des Identit√©s de fonctions sont ordonn√©es par un tri ascendant sur leurs valeurs.

`20965255` < `3FA4F245` < `55241077` < `E778DDC1`


##### getter() automatique

La fonction d'identit√© `3FA4F245` est en fait un **getter** automatique de la donn√©e publique `value`, elle est g√©n√©r√©e par le compilateur.

```solidity
  uint256 public value;
```

Nous retrouvons d'ailleurs dans les opcodes, l'identit√© de s√©lection (`3FA4F245`) et la fonction (√† l'adresse `tag 4`) du getter automatique pour cette variable.

**S√©lecteur** :
```yul
  DUP1 
  PUSH 3FA4F245  
  EQ 
  PUSH [tag] 4
  JUMPI 
```

**Fonction** :
```yul
tag 4
  JUMPDEST 
  PUSH [tag] 11
  PUSH [tag] 12
  JUMP [in]
tag 11
  JUMPDEST 
  PUSH 40
  MLOAD 
  PUSH [tag] 13
  SWAP2 
  SWAP1 
  PUSH [tag] abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed_0
  JUMP [in]
tag 13
  JUMPDEST 
  PUSH 40
  MLOAD 
  DUP1 
  SWAP2 
  SUB 
  SWAP1 
  RETURN
```

`getter` ayant d'ailleurs un code identique √† celui de la fonction `getValue()`

```yul
tag getValue_0
  JUMPDEST 
  PUSH [tag] getValue_1
  PUSH [tag] getValue_3
  JUMP [in]
tag getValue_1
  JUMPDEST 
  PUSH 40
  MLOAD 
  PUSH [tag] getValue_2
  SWAP2 
  SWAP1 
  PUSH [tag] abi_encode_tuple_t_uint256__to_t_uint256__fromStack_reversed_0
  JUMP [in]
tag getValue_2
  JUMPDEST 
  PUSH 40
  MLOAD 
  DUP1 
  SWAP2 
  SUB 
  SWAP1 
  RETURN 
```

D√©montrant ainsi l'inutilit√© d'avoir la variable `value` avec l'attribut `public` de concert avec la fonction `getValue()` mais √©galement une faiblesse du compilateur de Solidity `solc` qui ne peut fusioner le code des deux fonctions.

Voici d'ailleurs un lien, pour ceux qui voudraient aller plus loin, [**un article d√©taill√©**](https://medium.com/coinmonks/soliditys-cheap-public-face-b4e972e3924d) (üá¨üáß) sur les `automatic storage getters` en Solidity. Dont on peut r√©sum√© le contenu en quatre points essentiels.

1. Utilisez les getters automatique de Solidity lorsque cela est possible, car ils seront toujours similaires ou moins chers en Gas que les getters explicites. Dans certains cas, par exemple une structure de stockage publique (`public` storage) ils peuvent √™tre le seul moyen de fournir un getter.

2. Bien que le code source du contrat avec les getters automatique soit plus court que celui avec des getters explicites, le co√ªt du gaz est sensiblement le m√™me. Les getters automatique ne sont pas ¬´ *gratuits* ¬ª.

3. Ne publiez que les variables de stockage qui sont essentielles, en raison du co√ªt du Gas. En particulier, essayez d'√©viter les getters pour les structures de donn√©es dynamiques. Les types de structures complexes, y compris les cha√Ænes, sont assez co√ªteux √† rendre publics.

4. Des getters explicites peuvent √™tre requis pour les types `array` et `mapping`. Ils ne sont pas g√©n√©r√©s automatiquement.


### En **Yul**

Voici un extrait d'un exemple de [**contrat ERC20**](https://docs.soliditylang.org/en/develop/yul.html#complete-erc20-example) (üá¨üáß) enti√®rement √©crit en **Yul**.

```yul
object "runtime" {
    code {
        // Protection against sending Ether
        require(iszero(callvalue()))

        // Dispatcher
        switch selector()
        case 0x70a08231 /* "balanceOf(address)" */ {
            returnUint(balanceOf(decodeAsAddress(0)))
        }
        case 0x18160ddd /* "totalSupply()" */ {
            returnUint(totalSupply())
        }
        case 0xa9059cbb /* "transfer(address,uint256)" */ {
            transfer(decodeAsAddress(0), decodeAsUint(1))
            returnTrue()
        }
        case 0x23b872dd /* "transferFrom(address,address,uint256)" */ {
            transferFrom(decodeAsAddress(0), decodeAsAddress(1), decodeAsUint(2))
            returnTrue()
        }
        case 0x095ea7b3 /* "approve(address,uint256)" */ {
            approve(decodeAsAddress(0), decodeAsUint(1))
            returnTrue()
        }
        case 0xdd62ed3e /* "allowance(address,address)" */ {
            returnUint(allowance(decodeAsAddress(0), decodeAsAddress(1)))
        }
        case 0x40c10f19 /* "mint(address,uint256)" */ {
            mint(decodeAsAddress(0), decodeAsUint(1))
            returnTrue()
        }
        default {
            revert(0, 0)
        }

        /* ---------- calldata decoding functions ----------- */
        function selector() -> s {
            s := div(calldataload(0), 0x100000000000000000000000000000000000000000000000000000000)
        }

  ...

```

On y retrouve la suite de structure de `if/else` en cascade, identique au diagramme pr√©c√©dent.

R√©aliser un contrat **100% en Yul**, oblige √† coder soi m√™me le "*function dispatcher*", ce qui implique que l'on peut choisir l'ordre de traitement des Identit√©s, ainsi qu'utiliser d'autres algorithme qu'une simple suite de tests.


## Un exemple simple


## L'ordre de traitement
- Ordre des fonctions dans le code source
- Ordonnanc√© par la valeur de hash

### Recherche lin√©aire

### Recherche par dichotomie

## Optimisations

### Optimisation au d√©ploiement

### optimisation √† l'ex√©cution

Seuil(s) pivot

Cette op√©ration requiert un temps en **O(log(n))** dans le cas moyen, mais **O(n)** dans le cas critique o√π l'arbre est compl√®tement d√©s√©quilibr√© et ressemble √† une liste cha√Æn√©e. Ce probl√®me est √©cart√© si l'arbre est √©quilibr√© par rotation au fur et √† mesure des insertions pouvant cr√©er des listes trop longues. 
[Wikip√©dia](https://fr.wikipedia.org/wiki/Arbre_binaire_de_recherche#Recherche) (üá´üá∑)


## Conclusions

Le "*function dispatcher*" est ainsi le reflet de l'ABI.

L'optimisation pour l'ex√©cution n'est pas n√©cessaire pour les fonctions dites d'administration. Par contre c'est √† prioriser pour les fonctions suppos√©ment les plus fr√©quemment appel√©es (√† d√©terminer manuellement ou statistiquement lors de tests pratiques)

Merci √† [**Igor Bournazel**](https://github.com/ibourn) pour la relecture technique de cet article.


## Liens

- Fonction de hachage
  - üá´üá∑ [Fonction de hachage ‚Äî Wikip√©dia](https://fr.wikipedia.org/wiki/Fonction_de_hachage)
  - üá¨üáß [Hash function - Wikipedia](https://en.wikipedia.org/wiki/Hash_function)

- Keccak
  - üá´üá∑ [SHA-3 ‚Äî Wikip√©dia](https://fr.wikipedia.org/wiki/SHA-3)
  - üá¨üáß [SHA-3 - Wikipedia](https://en.wikipedia.org/wiki/SHA-3)
  - üá¨üáß [Difference Between SHA-256 and Keccak-256 - GeeksforGeeks](https://www.geeksforgeeks.org/difference-between-sha-256-and-keccak-256/)

- Recherche dichotomique
  - üá´üá∑ [Recherche dichotomique ‚Äî Wikip√©dia](https://fr.wikipedia.org/wiki/Recherche_dichotomique)
  - üá¨üáß [Binary search algorithm - Wikipedia](https://en.wikipedia.org/wiki/Binary_search_algorithm)

- Ref√©rences
  - üá¨üáß [Ethereum Yellow Paper](https://ethereum.github.io/yellowpaper/paper.pdf)
  - üá¨üáß [Contract ABI Specification ‚Äî Solidity 0.8.22 documentation](https://docs.soliditylang.org/en/develop/abi-spec.html#function-selector)
  - üá¨üáß [Yul ‚Äî Solidity 0.8.22 documentation](https://docs.soliditylang.org/en/latest/yul.html)
  - üá¨üáß [Yul ‚Äî Complete ERC20 Example](https://docs.soliditylang.org/en/develop/yul.html#complete-erc20-example)

- Outils
  - üá¨üáß [Keccak-256 Online](http://emn178.github.io/online-tools/keccak_256.html)
  - üá¨üáß [Compiler Explorer](https://godbolt.org/)
  - üá¨üáß [Solidity Optimize Name](https://emn178.github.io/solidity-optimize-name/)
  - üá¨üáß [Ethereum Signature Database](https://www.4byte.directory/)

- Divers
  - üá¨üáß [Function Dispatching | Huff Language](https://docs.huff.sh/tutorial/function-dispatching/#linear-dispatching)
  - üá¨üáß [Solidity‚Äôs Cheap Public Face](https://medium.com/coinmonks/soliditys-cheap-public-face-b4e972e3924d)


